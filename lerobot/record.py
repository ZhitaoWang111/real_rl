# Copyright 2024 The HuggingFace Inc. team. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Records a dataset. Actions for the robot can be either generated by teleoperation or by a policy.

Example:

```shell
python -m lerobot.record \
    --robot.type=so100_follower \
    --robot.port=/dev/tty.usbmodem58760431541 \
    --robot.cameras="{laptop: {type: opencv, camera_index: 0, width: 640, height: 480}}" \
    --robot.id=black \
    --teleop.type=so100_leader \
    --teleop.port=/dev/tty.usbmodem58760431551 \
    --teleop.id=blue \
    --dataset.repo_id=aliberts/record-test \
    --dataset.num_episodes=2 \
    --dataset.single_task="Grab the cube"
```
    --robot.cameras="{laptop: {type: opencv, camera_index: 0, width: 640, height: 480}}" \
"""

"""
python -m lerobot.record \
    --robot.type=moving_dual_piper \
    --robot.port="" \
    --robot.id=mobile_ai_robot \
    --dataset.repo_id=kelo/vla_test \
    --dataset.num_episodes=2 \
    --dataset.single_task="Grab the cube"
"""

import logging
import time
from dataclasses import asdict, dataclass
from pathlib import Path
from pprint import pformat

import numpy as np
import rerun as rr

from lerobot.common.cameras import (  # noqa: F401
    CameraConfig,  # noqa: F401
)
from lerobot.common.cameras.opencv.configuration_opencv import OpenCVCameraConfig  # noqa: F401
from lerobot.common.cameras.realsense.configuration_realsense import RealSenseCameraConfig  # noqa: F401
from lerobot.common.datasets.image_writer import safe_stop_image_writer
from lerobot.common.datasets.lerobot_dataset import LeRobotDataset
from lerobot.common.datasets.utils import build_dataset_frame, hw_to_dataset_features
from lerobot.common.policies.factory import make_policy
from lerobot.common.policies.pretrained import PreTrainedPolicy
from lerobot.common.robots import (  # noqa: F401
    Robot,
    RobotConfig,
    make_robot_from_config,
    single_piper,
    dual_piper,
    moving_dual_piper,
)
from lerobot.common.utils.control_utils import (
    init_keyboard_listener,
    is_headless,
    predict_action,
    sanity_check_dataset_name,
    sanity_check_dataset_robot_compatibility,
)
from lerobot.common.utils.robot_utils import busy_wait
from lerobot.common.utils.utils import (
    get_safe_torch_device,
    init_logging,
    log_say,
)
from lerobot.common.utils.visualization_utils import _init_rerun
from lerobot.configs import parser
from lerobot.configs.policies import PreTrainedConfig

from typing import Any

# from .common.teleoperators import koch_leader, so100_leader, so101_leader  # noqa: F401


@dataclass
class DatasetRecordConfig:
    # Dataset identifier. By convention it should match '{hf_username}/{dataset_name}' (e.g. `lerobot/test`).
    repo_id: str
    # A short but accurate description of the task performed during the recording (e.g. "Pick the Lego block and drop it in the box on the right.")
    single_task: str
    # Root directory where the dataset will be stored (e.g. 'dataset/path').
    root: str | Path | None = None
    # Limit the frames per second.
    fps: int = 30
    # Number of seconds for data recording for each episode.
    episode_time_s: int | float = 60
    # Number of seconds for resetting the environment after each episode.
    reset_time_s: int | float = 10
    # Number of episodes to record.
    num_episodes: int = 50
    # Encode frames in the dataset into video
    video: bool = False
    # Upload dataset to Hugging Face hub.
    push_to_hub: bool = False
    # Upload on private repository on the Hugging Face hub.
    private: bool = False
    # Add tags to your dataset on the hub.
    tags: list[str] | None = None
    # Number of subprocesses handling the saving of frames as PNG. Set to 0 to use threads only;
    # set to ≥1 to use subprocesses, each using threads to write images. The best number of processes
    # and threads depends on your system. We recommend 4 threads per camera with 0 processes.
    # If fps is unstable, adjust the thread count. If still unstable, try using 1 or more subprocesses.
    num_image_writer_processes: int = 1
    # Number of threads writing the frames as png images on disk, per camera.
    # Too many threads might cause unstable teleoperation fps due to main thread being blocked.
    # Not enough threads might cause low camera fps.
    num_image_writer_threads_per_camera: int = 4

    def __post_init__(self):
        if self.single_task is None:
            raise ValueError("You need to provide a task as argument in `single_task`.")


@dataclass
class RecordConfig:
    robot: RobotConfig
    dataset: DatasetRecordConfig
    # Whether to control the robot with a policy
    policy: PreTrainedConfig | None = None
    # Display all cameras on screen
    display_data: bool = False
    # Use vocal synthesis to read events.
    play_sounds: bool = True
    # Resume recording on an existing dataset.
    resume: bool = True


    def __post_init__(self):

        # HACK: We parse again the cli args here to get the pretrained path if there was one.
        policy_path = parser.get_path_arg("policy")
        if policy_path:
            cli_overrides = parser.get_cli_overrides("policy")
            self.policy = PreTrainedConfig.from_pretrained(policy_path, cli_overrides=cli_overrides)
            self.policy.pretrained_path = policy_path

    @classmethod
    def __get_path_fields__(cls) -> list[str]:
        """This enables the parser to load config from the policy using `--policy.path=local/dir`"""
        return ["policy"]


@safe_stop_image_writer
def record_loop(
    robot: Robot,
    events: dict,
    fps: int,
    dataset: LeRobotDataset | None = None,
    policy: PreTrainedPolicy | None = None,
    control_time_s: int | None = None,
    single_task: str | None = None,
    display_data: bool = False,
):
    if dataset is not None and dataset.fps != fps:
        raise ValueError(f"The dataset fps should be equal to requested fps ({dataset.fps} != {fps}).")

    # if policy is given it needs cleaning up
    if policy is not None:
        policy.reset()

    threshold_update_timeout_s = 20  # 关节角信息不更新的时间超过阈值则认为是异常
    zero_joints_timeout_s = 10  # 关节角数据持续为0的时间超过阈值则认为是异常

    if isinstance(robot, single_piper.SinglePiper):
        last_update_t = time.perf_counter()
        last_observation = {}
        zero_joints_start_t = None  # 记录关节角开始为0的时间
        all_joints_zero = False
    elif isinstance(robot, dual_piper.DualPiper) or isinstance(robot, moving_dual_piper.MovingDualPiper):
        last_update_left_t = time.perf_counter()
        last_observation_left = {}
        last_update_right_t = time.perf_counter()
        last_observation_right = {}
        zero_joints_left_start_t = None  # 记录左臂关节角开始为0的时间
        zero_joints_right_start_t = None  # 记录右臂关节角开始为0的时间
        all_left_joints_zero = False
        all_right_joints_zero = False

    timestamp = 0
    start_episode_t = time.perf_counter()
    while timestamp < control_time_s:
        start_loop_t = time.perf_counter()

        observation = robot.get_observation()
        action: dict[str, Any] = {}
        sent_action = robot.send_action(action)

        # 检查关节角是否更新以及是否长时间为0
        joints = ('joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6')
        if isinstance(robot, single_piper.SinglePiper):
            # 检查是否所有关节角都为0
            all_zeros = True
            for joint in joints:
                # single arm
                obs_key = f"{joint}.pos"
                val = observation[obs_key]
                if isinstance(val, float):
                    if val != last_observation.get(obs_key, None):
                        last_update_t = time.perf_counter()
                        last_observation[obs_key] = val
                    if abs(val) > 1e-6:  # 非零值
                        all_zeros = False
                elif isinstance(val, np.ndarray):
                    if not np.array_equal(val, last_observation.get(obs_key, None)):
                        last_update_t = time.perf_counter()
                        last_observation[obs_key] = val
                    if np.any(np.abs(val) > 1e-6):  # 数组中有非零值
                        all_zeros = False
            
            # 检查关节角更新超时
            dt_update_s = time.perf_counter() - last_update_t
            if dt_update_s > threshold_update_timeout_s:
                print(f"WARNING: 关节角数据长时间未发生变化 (超过 {threshold_update_timeout_s} 秒)")
                last_update_t = time.perf_counter()  # 重置计时器，避免重复输出警告
            
            # 检查关节角长时间为0
            if all_zeros:
                if not all_joints_zero:  # 首次检测到全为0
                    zero_joints_start_t = time.perf_counter()
                    all_joints_zero = True
                elif time.perf_counter() - zero_joints_start_t > zero_joints_timeout_s:
                    print(f"WARNING: 未检测到有效关节角数据 (超过 {zero_joints_timeout_s} 秒)")
                    zero_joints_start_t = time.perf_counter()  # 重置计时器，避免重复输出警告
            else:
                all_joints_zero = False
                zero_joints_start_t = None

        elif isinstance(robot, dual_piper.DualPiper) or isinstance(robot, moving_dual_piper.MovingDualPiper):
            # 检查左右臂关节角是否全为0
            all_left_zeros = True
            all_right_zeros = True
            
            for joint in joints:
                # left arm
                left_obs_key = f"left_{joint}.pos"
                left_val = observation[left_obs_key]
                if isinstance(left_val, float):
                    if left_val != last_observation_left.get(left_obs_key, None):
                        last_update_left_t = time.perf_counter()
                        last_observation_left[left_obs_key] = left_val
                    if abs(left_val) > 1e-6:  # 非零值
                        all_left_zeros = False
                elif isinstance(left_val, np.ndarray):
                    if not np.array_equal(left_val, last_observation_left.get(left_obs_key, None)):
                        last_update_left_t = time.perf_counter()
                        last_observation_left[left_obs_key] = left_val
                    if np.any(np.abs(left_val) > 1e-6):  # 数组中有非零值
                        all_left_zeros = False

                # right arm
                right_obs_key = f"right_{joint}.pos"
                right_val = observation[right_obs_key]
                if isinstance(right_val, float):
                    if right_val != last_observation_right.get(right_obs_key, None):
                        last_update_right_t = time.perf_counter()
                        last_observation_right[right_obs_key] = right_val
                    if abs(right_val) > 1e-6:  # 非零值
                        all_right_zeros = False
                elif isinstance(right_val, np.ndarray):
                    if not np.array_equal(right_val, last_observation_right.get(right_obs_key, None)):
                        last_update_right_t = time.perf_counter()
                        last_observation_right[right_obs_key] = right_val
                    if np.any(np.abs(right_val) > 1e-6):  # 数组中有非零值
                        all_right_zeros = False
        
            # 检查关节角更新超时
            dt_update_left_s = time.perf_counter() - last_update_left_t
            if dt_update_left_s > threshold_update_timeout_s:
                print(f"WARNING: 左臂关节角数据长时间未发生变化 (超过 {threshold_update_timeout_s} 秒)")
                last_update_left_t = time.perf_counter()  # 重置计时器，避免重复输出警告
            dt_update_right_s = time.perf_counter() - last_update_right_t
            if dt_update_right_s > threshold_update_timeout_s:
                print(f"WARNING: 右臂关节角数据长时间未发生变化 (超过 {threshold_update_timeout_s} 秒)")
                last_update_right_t = time.perf_counter()  # 重置计时器，避免重复输出警告
            
            # 检查左臂关节角长时间为0
            if all_left_zeros:
                if not all_left_joints_zero:  # 首次检测到全为0
                    zero_joints_left_start_t = time.perf_counter()
                    all_left_joints_zero = True
                elif time.perf_counter() - zero_joints_left_start_t > zero_joints_timeout_s:
                    print(f"WARNING: 左臂未检测到有效关节角数据 (超过 {zero_joints_timeout_s} 秒)")
                    zero_joints_left_start_t = time.perf_counter()  # 重置计时器，避免重复输出警告
            else:
                all_left_joints_zero = False
                zero_joints_left_start_t = None
                
            # 检查右臂关节角长时间为0
            if all_right_zeros:
                if not all_right_joints_zero:  # 首次检测到全为0
                    zero_joints_right_start_t = time.perf_counter()
                    all_right_joints_zero = True
                elif time.perf_counter() - zero_joints_right_start_t > zero_joints_timeout_s:
                    print(f"WARNING: 右臂未检测到有效关节角数据 (超过 {zero_joints_timeout_s} 秒)")
                    zero_joints_right_start_t = time.perf_counter()  # 重置计时器，避免重复输出警告
            else:
                all_right_joints_zero = False
                zero_joints_right_start_t = None

        if dataset is not None:
            observation_frame = build_dataset_frame(dataset.features, observation, prefix="observation")

        if dataset is not None:
            action_frame = build_dataset_frame(dataset.features, sent_action, prefix="action")
            frame = {**observation_frame, **action_frame}
            dataset.add_frame(frame, task=single_task)

        if display_data:
            for obs, val in observation.items():
                if isinstance(val, float):
                    rr.log(f"observation.{obs}", rr.Scalar(val))
                elif isinstance(val, np.ndarray):
                    rr.log(f"observation.{obs}", rr.Image(val), static=True)
            for act, val in action.items():
                if isinstance(val, float):
                    rr.log(f"action.{act}", rr.Scalar(val))
        
        dt_s = time.perf_counter() - start_loop_t
        busy_wait(1 / fps - dt_s)

        timestamp = time.perf_counter() - start_episode_t
        if events["exit_early"]:
            events["exit_early"] = False
            break


@parser.wrap()
def record(cfg: RecordConfig) -> LeRobotDataset:
    init_logging()
    logging.info(pformat(asdict(cfg)))
    if cfg.display_data:
        _init_rerun(session_name="recording")

    robot = make_robot_from_config(cfg.robot)

    action_features = hw_to_dataset_features(robot.action_features, "action", cfg.dataset.video)
    obs_features = hw_to_dataset_features(robot.observation_features, "observation", cfg.dataset.video)
    dataset_features = {**action_features, **obs_features}

    if cfg.resume:
        dataset = LeRobotDataset(
            cfg.dataset.repo_id,
            root=cfg.dataset.root,
        )

        if hasattr(robot, "cameras") and len(robot.cameras) > 0:
            dataset.start_image_writer(
                num_processes=cfg.dataset.num_image_writer_processes,
                num_threads=cfg.dataset.num_image_writer_threads_per_camera * len(robot.cameras),
            )
        sanity_check_dataset_robot_compatibility(dataset, robot, cfg.dataset.fps, dataset_features)
    else:
        # Create empty dataset or load existing saved episodes
        sanity_check_dataset_name(cfg.dataset.repo_id, cfg.policy)
        dataset = LeRobotDataset.create(
            cfg.dataset.repo_id,
            cfg.dataset.fps,
            root=cfg.dataset.root,
            robot_type=robot.name,
            features=dataset_features,
            use_videos=cfg.dataset.video,
            image_writer_processes=cfg.dataset.num_image_writer_processes,
            image_writer_threads=cfg.dataset.num_image_writer_threads_per_camera * len(robot.cameras),
        )

    # Load pretrained policy
    policy = None if cfg.policy is None else make_policy(cfg.policy, ds_meta=dataset.meta)

    robot.connect()
    # if teleop is not None:
    #     teleop.connect()

    listener, events = init_keyboard_listener()

    for recorded_episodes in range(cfg.dataset.num_episodes):
        log_say(f"Recording episode {dataset.num_episodes}", cfg.play_sounds)
        record_loop(
            robot=robot,
            events=events,
            fps=cfg.dataset.fps,
            policy=policy,
            dataset=dataset,
            control_time_s=cfg.dataset.episode_time_s,
            single_task=cfg.dataset.single_task,
            display_data=cfg.display_data,
        )

        # Execute a few seconds without recording to give time to manually reset the environment
        # Skip reset for the last episode to be recorded
        if not events["stop_recording"] and (
            (recorded_episodes < cfg.dataset.num_episodes - 1) or events["rerecord_episode"]
        ):
            log_say("Reset the environment", cfg.play_sounds)
            record_loop(
                robot=robot,
                events=events,
                fps=cfg.dataset.fps,
                control_time_s=cfg.dataset.reset_time_s,
                single_task=cfg.dataset.single_task,
                display_data=cfg.display_data,
            )

        if events["rerecord_episode"]:
            log_say("Re-record episode", cfg.play_sounds)
            events["rerecord_episode"] = False
            events["exit_early"] = False
            dataset.clear_episode_buffer()
            continue

        dataset.save_episode()

        if events["stop_recording"]:
            break

    log_say("Stop recording", cfg.play_sounds, blocking=True)

    robot.disconnect()

    if not is_headless() and listener is not None:
        listener.stop()

    if cfg.dataset.push_to_hub:
        dataset.push_to_hub(tags=cfg.dataset.tags, private=cfg.dataset.private)

    log_say("Exiting", cfg.play_sounds)
    return dataset


if __name__ == "__main__":
    record()
